e = 0; es = 1;  
% e: e를 구하기 위해 0보다 큰 수를 반복적으로 반절로 나눠진 수
% es: 0과 가장 가까운 수
while(1)
    e = es / 2;     % e는 0보다 큰 수중에서 es를 계속 반절로 나눈 수이다.
    if e == 0 , break, end;     % e가 0과 근사해지면 es가 0보다 큰 가장 작은수가 된다.
    es = e; % 반절로 나눠진 e를 es에 초기화
end
fprintf('es = %d\n', es);    % 0보다 큰 가장 작은 수 es 출력
fprintf('log2(es) = %d\n', log2(es));  % es에 밑이 2인 log를 취한 값

% 0보다 큰 가장 작은 수를 구하기 위해 0에 근사시키는 방법으로 반복적으로 2로 나눈다.
% 반절로 나눠진 e는 es에 다시 초기화 시키고, 
% 반절로 나눠진 es를 다시 반절로 나누어 e에 저장하고 이를 다시 es에 저장하는 것을 반복한다.
% 만약 e가 0과 같아지면 이때 es는 0보다 크면서 가장 작은 수를 나타낼 것이다.

% es = 4.940656e-324, log2(es) = -1074
% realmin = 2.2251e-308, log2(realmin) = -1022